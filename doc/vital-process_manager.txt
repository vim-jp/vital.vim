*vital-process_manager.txt*	process manager with vimproc.

Maintainer: ujihisa <ujihisa at gmail com>

==============================================================================
CONTENTS			*Vital.ProcessManager-contents*

INTRODUCTION			|Vital.ProcessManager-introduction|
  USAGE				|Vital.ProcessManager-usage|
  PRINCIPLE			|Vital.ProcessManager-principle|
INTERFACE			|Vital.ProcessManager-interface|
  FUNCTIONS			  |Vital.ProcessManager-functions|
VERSION UP MIGRATION		|Vital.ProcessManager-migration-1to2|


==============================================================================
INTRODUCTION			*Vital.ProcessManager-introduction*

*Vital.ProcessManager* is a Vim's process manager library, powered by
|vimproc|.  This manager stores external processes ran by this library, and
provide higher layer synchronous non-blocking read/write interface.

Note that this library doesn't work on Vim without vimproc; vimproc is
required.


==============================================================================
USAGE					*Vital.ProcessManager-usage*
A code example that keeps /usr/bin/bash process and uses it without stopping.
>
	let s:P = g:V.import('ProcessManager')

	function! s:benri()
	  if !s:P.is_available() " please always check if it's available.
	    throw 'omg'
	  endif

	  " Create/refer the ProcessManager object represents the process.
	  " Add --norc and -i options to force it behaves interactively.
	  let p = s:P.of('pm-doc-sample-bash', 'bash --norc -i')

	  " The p may be already created by somebody. That way this p just referes the
	  " existing one. The below if block will be executed only when this p is
	  " really new.
	  if p.is_new()
	    " The default prompt is probably like 'ujihisa@host ~ $ ' but it's too
	    " fragile. Let's change the prompt.
	    call p.reserve_wait(['.*\$ $'])
		  \.reserve_writeln('export PS1="\nPM-DOC-SAMPLE-BASH$ "')
		  \.reserve_wait(['PM-DOC-SAMPLE-BASH\$ '])
	  endif

	  " Ok so what should I do? Let's just check current time.
	  call p.reserve_writeln('date')
		\.reserve_read(['PM-DOC-SAMPLE-BASH\$ '])

	  " Let's block Vim to get complete result.
	  while 1
	    let result = p.go_bulk()
	    if result.done
	      echomsg string([result])
	      break
	    endif
	  endwhile
	endfunction

	call s:benri()
<

USAGE-OLD				*Vital.ProcessManager-usage-old*

SOFT DEPRECATED. See |Vital.ProcessManager-migration-1to2|.
>
	let P = V.import('ProcessManager')
	if !P.is_available() " please always check if it's available.
	  throw "omg"
	endif
	call P.touch('i', 'clojure-1.5') " creates a process that runs clojure
	" read the stdout/stderr and wait until the process's output stays
	" same for 2.0 sec.
	echo P.read_wait('i', 2.0, [])
	call P.writeln('i', '(+ 2 3)')
	" read the stdout/stderr and wait until the process's output stays
	" same for 0.05 sec.
	echo P.read('i', []) " ["5\nuser=>", '', 'timedout']
	" kills the process, and let ProcessManager forget it.
	echo P.term('i') " gracefully stop the process
	echo P.status('i') " 'inactive'
<

>
	" An alternative way with label
	function! s:f(x)
	  let t = P.touch('my-scala', 'scala')
	  if t ==# 'new'
	    " wait for longer time to make sure scala runs, since scala is
	    " really slow to be ready.
	    let [out, err, type] = P.read_wait('my-scala', 2.0, ['scala> '])
	    if type ==# 'timedout'
	      throw 'omg it took too much time'
	    endif
	  endif
	  call P.writeln('my-scala', a:x)
	  let [out, err, type] = P.read('my-scala', ['scala> '])
	  if type ==# 'timedout'
	    throw 'something easy to do please'
	  elseif type ==# 'inactive'
	    throw 'scala had died...!'
	  endif
	  return out
	endfunction

	echo s:f('1 + 2') "=> '3' but slow
	echo s:f('2 + 3') "=> '5' and fast!
<

==============================================================================
PRINCIPLE			*Vital.ProcessManager-principle*

* Nonblocking
  * blocking APIs should have verbose name to discourage developers to use
* Synchronous (asynchronous in Vim always makes trouble)
* Don't show lower layer too much easily, but don't hide completely. No
  perfect abstraction exists in the world.
* Avoid tricky specification. Function name and behaviour itself should
  explain what it does.
>
==============================================================================
INTERFACE			*Vital.ProcessManager-interface*

------------------------------------------------------------------------------
FUNCTIONS			*Vital.ProcessManager-functions*

touch({label}, {cmd})		*Vital.ProcessManager.touch()*
	SOFT DEPRECATED. See |Vital.ProcessManager-migration-1to2|.

	Returns a string which is either "existing" or "new".

state({label})			*Vital.ProcessManager.state()*
	SOFT DEPRECATED. See |Vital.ProcessManager-migration-1to2|.

	Returns either "undefined", "inactive", "reading", or "idle".

of()				*Vital.ProcessManager.of()*
	TODO
is_new()			*Vital.ProcessManager.is_new()*
	TODO
is_idle()			*Vital.ProcessManager.is_idle()*
	TODO
shutdown()			*Vital.ProcessManager.shutdown()*
	TODO
				*Vital.ProcessManager.reserve_wait({endpatterns})*
reserve_wait({endpatterns})
	TODO
				*Vital.ProcessManager.reserve_writeln({line})*
reserve_writeln({line})
	TODO
reserve_read({endpatterns})	*Vital.ProcessManager.reserve_read({endpatterns})*
	TODO
go_bulk()			*Vital.ProcessManager.go_bulk()*
	TODO
go_part()			*Vital.ProcessManager.go_part()*
	TODO
tick()				*Vital.ProcessManager.tick()*
	TODO

==============================================================================
VERSION UP MIGRATION		*Vital.ProcessManager-migration-1to2*

ProcessManager had changed its API in Novemeber 2014. Avoid using all
functions which are marked as SOFT DEPRECATED. SOFT DEPRECATED functions will
be marked as DEPRECATED, and then removed in the future.


==============================================================================
vim:tw=78:fo=tcq2mM:ts=8:ft=help:norl
