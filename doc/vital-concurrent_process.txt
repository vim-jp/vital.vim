*vital-concurrent_process.txt*	Manages process concurrently with vimproc.

Maintainer: ujihisa <ujihisa at gmail com>

==============================================================================
CONTENTS			*Vital.ConcurrentProcess-contents*

INTRODUCTION			|Vital.ConcurrentProcess-introduction|
  USAGE				|Vital.ConcurrentProcess-usage|
  PRINCIPLE			|Vital.ConcurrentProcess-principle|
INTERFACE			|Vital.ConcurrentProcess-interface|
  FUNCTIONS			  |Vital.ConcurrentProcess-functions|
CONFIG				|Vital.ConcurrentProcess-config|



==============================================================================
INTRODUCTION			*Vital.ConcurrentProcess-introduction*

*Vital.ConcurrentProcess* is to communicate with external process concurrently
with using |vimproc|.  This library stores external processes information
spawned by this library, and provides higher layer concurrent synchronous
non-blocking read/write interface. This library doesn't use thread nor fork,
so by nature this library can't crash Vim by them.

Note that this library doesn't work on Vim without vimproc; vimproc is
required.


==============================================================================
USAGE				*Vital.ConcurrentProcess-usage*

TODO

==============================================================================
PRINCIPLE			*Vital.ConcurrentProcess-principle*

* Nonblocking by default
  * blocking APIs should have verbose name to discourage developers to use
* Timeout is required if it's blocking
  * Remember that: not to specify timeout is same to specify timeout as
    forever. Having 30 year timeout explicitly is better than to specify
    forever implicitly.
* Synchronous (asynchronous in Vim always makes trouble)
* Don't show lower layer too much easily, but don't hide completely. No
  perfect abstraction exists in the world.
* Avoid tricky specification. Function name and behaviour itself should
  explain what it does.
>
==============================================================================
INTERFACE			*Vital.ConcurrentProcess-interface*

The following function is to start a process.
	|Vital.ConcurrentProcess.of()|
The following function is to terminate a process.
	|Vital.ConcurrentProcess.shutdown()|
The following function is to change queries in queue.
	|Vital.ConcurrentProcess.queue()|
The following functions are to obtain information with side effect, based on
queries in the queue and etc.
	|Vital.ConcurrentProcess.consume()|
	|Vital.ConcurrentProcess.consume_all_blocking()|
	|Vital.ConcurrentProcess.is_done()|
	|Vital.ConcurrentProcess.is_busy()|
The following functions are for debugging.
	|Vital.ConcurrentProcess.log_clear()|
	|Vital.ConcurrentProcess.log_dump()|
Etc
	|Vital.ConcurrentProcess.tick()|
	|Vital.ConcurrentProcess.is_available()|

------------------------------------------------------------------------------
FUNCTIONS			*Vital.ConcurrentProcess-functions*

of({command}, {dir}, {list})			*Vital.ConcurrentProcess.of()*
	Spawns an external process based on the arguments, and returns a
	string which is used as |Vital.ConcurrentProcess-term.label| later.

	Besides the side-effect, the return value is idempotent; if you give
	exactly same arguments, this function always returns exactly same
	string.

	Check |Vital.ConcurrentProcess-usage| how to use this with other
	functions.

	Idempotent? Yes -- but side-effect can be different.

is_available()			*Vital.ConcurrentProcess.is_available()*
	Returns 1 if the running Vim can use ConcurrentProcess, otherwise 0.

	Idempotent? Yes

tick({label})				*Vital.ConcurrentProcess.tick()*
	This is an action |Vital.ConcurrentProcess-term.action|, and does
	nothing besides action.

queue({label}, {list})			*Vital.ConcurrentProcess.queue()*
	Pushes the given {list} of queries into the queue for the process.
	The query has to be either one of them.
	['*writeln*', string]
	['*read*', string, string]
	['*read-all', string]

>
	call s:CP.queue(label, [
	      \ ['*writeln*', '1 + 2'],
	      \ ['*read*', 'x', '> ']])
	let [out, err] = s:CP.consume(label, 'x')
	" out may contain "3"
<

consume({label}, {varname})		*Vital.ConcurrentProcess.consume()*
	This is an action |Vital.ConcurrentProcess-term.action|, and returns
	accumulated value for {varname} immediately, and remove it from
	internal buffer.

	similar to consume() described above, but this doesn't immediately
	return the current output but blocks until the end of the read of the
	given {varname}, at most {timeout-sec} seconds. This also returns a
	0/1 value as the 3rd element of the list to tell if it has timed out
	or not.

	Idempotent? No -- this removes the internal buffer.

consume_all_blocking({label}, {varname}, {timeout-sec})
			*Vital.ConcurrentProcess.consume_all_blocking()*
	This is an action |Vital.ConcurrentProcess-term.action|, and does
	similar to consume() described above, but this doesn't immediately
	return the current output but blocks until the end of the read of the
	given {varname}, at most {timeout-sec} seconds. This also returns a
	0/1 value as the 3rd element of the list to tell if it has timed out
	or not.
>
	" get stdout/stderr for the var x, with blocking at worst 10 seconds.
	let [out, err, timeout_p] =
	      \ s:CP.consume_all_blocking(label, 'x', 10)
	if timeout_p
	  " omg it timed out!
	else
	  " yes it completed without 10 seconds. Do normal stuff here
	endif
<
	For your info this function is internally using is_done() described
	below.

	Idempotent? No -- this removes the internal buffer.

is_done({label}, {varname})		*Vital.ConcurrentProcess.is_done()*
	This is an action |Vital.ConcurrentProcess-term.action|, and checks
	if the read operation of given {varname} has completed. You are
	particularly expected to use this function when you use consume().

	e.g.
	is_done(label, 'x') == 1 if you didn't read/read-all with 'x' yet
	is_done(label, 'x') == 1 if you did read/read-all with 'x' and it
	completed.
	is_done(label, 'x') == 1 if you did read/read-all with 'x' and it
	didn't complete, but the process crashed and after auto restart you
	didn't read/read-all yet.
	is_done(label, 'x') == 0 only if you did read/read-all with 'x' and it
	didn't complete nor crash yet.

	Idempotent? No -- return value depends on internal state.

is_busy({label})			*Vital.ConcurrentProcess.is_busy()*
	This is an action |Vital.ConcurrentProcess-term.action|, and checks
	if the queries are currently empty.

	Idempotent? No -- return value depends on internal state.

shutdown({label})			*Vital.ConcurrentProcess.shutdown()*
	Terminates the underlying process for the given label immediately, no
	matter how many queries are in the queue. This also removes all
	internal buffers for the process, including queries and logs.

log_clear({label})			*Vital.ConcurrentProcess.log_clear()*
	Just to wipe out accumulated logs for the process.

log_dump({label})			*Vital.ConcurrentProcess.log_dump()*
	Print out the accumulated logs for the process, and wipe out it.

	Idempotent? No -- output depends on the internal buffer and every time
	you call this ConcurrentProcess removes buffer.

------------------------------------------------------------------------------
TERMS				*Vital.ConcurrentProcess-terms*

label					*Vital.ConcurrentProcess-term.label*
	A string that represents a running/dead process managed by
	ConcurrentProcess.

action
	The external process runs in parallel independent to Vim, but the
	communication between Vim and the process is always done
	synchronously. A function which is an action, such as consume(), will
	trigger the communication; reads from stdout/stderr, or writes to stdin
	if there's corresponding queue.

	The following functions are actions.
	* |Vital.ConcurrentProcess.tick()|
	* |Vital.ConcurrentProcess.consume()|
	* |Vital.ConcurrentProcess.consume_all_blocking()|
	* |Vital.ConcurrentProcess.is_done()|
	* |Vital.ConcurrentProcess.queue()|
	* |Vital.ConcurrentProcess.is_busy()|

==============================================================================
vim:tw=78:fo=tcq2mM:ts=8:ft=help:norl
