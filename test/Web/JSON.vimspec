Describe Web.JSON
  Before all
    let JSON = vital#vital#new().import('Web.JSON')
  End

  Describe .constants()
    It should have constant variables which indicate the special tokens
      Assert Same(JSON.true, v:true)
      Assert Same(JSON.false, v:false)
      Assert Same(JSON.null, v:null)
    End
  End

  Describe .decode()
    It decodes numbers
      Assert Equals(JSON.decode(0), 0)
      Assert Equals(JSON.decode(10), 10)
      Assert Equals(JSON.decode(100), 100)
    End

    It decodes strings
      Assert Equals(JSON.decode('""'), '')
      Assert Equals(JSON.decode('"a"'), 'a')
      Assert Equals(JSON.decode('"a\rb"'), "a\rb")
      Assert Equals(JSON.decode('"a\nb"'), "a\nb")
      Assert Equals(JSON.decode('"a\tb"'), "a\tb")
      " double quotation
      Assert Equals(
            \ JSON.decode('"He said \"I''m a vimmer\""'),
            \ 'He said "I''m a vimmer"'
            \)
      " control chars
      Assert Equals(JSON.decode('"\u0001\u0002\u0003\u0004\u0005\u0006\u0007"'), "\x01\x02\x03\x04\x05\x06\x07")
      Assert Equals(JSON.decode('"\b\t\n\u000b\f\r\u000e\u000f"'), "\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f")
      Assert Equals(JSON.decode('"\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017"'), "\x10\x11\x12\x13\x14\x15\x16\x17")
      Assert Equals(JSON.decode('"\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f"'), "\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f")
      " multibyte
      Assert Equals(JSON.decode('"s¢cĴgё"'), "s¢cĴgё")
      " UTF-16 surrogate pair
      Assert Equals(JSON.decode('"\ud83c\udf63"'), "\xf0\x9f\x8d\xa3")
      " unpaired UTF-16 surrogate
      Assert Equals(JSON.decode('"\ud83c\u00a0"'), "\ud83c\u00a0")
    End

    It decodes strings with character encoding
      let expected_utf8 = "sあc漢g"
      Assert Equals(JSON.decode('"sあc漢g"'), expected_utf8)

      let expected_sjis = iconv("sあc漢g", 'utf-8', 'sjis')
      try
        let &encoding = 'sjis'
        let res = JSON.decode('"sあc漢g"')
      finally
        let &encoding = 'utf-8'
      endtry
      Assert Equals(res, expected_sjis)
    End

    It decodes lists
      Assert Equals(JSON.decode('[]'), [])
      Assert Equals(JSON.decode('[0, 1, 2]'), [0, 1, 2])
      Assert Equals(JSON.decode('["a", "b", "c"]'), ['a', 'b', 'c'])
      " list should be encoded recursively
      Assert Equals(
            \ JSON.decode('[[0, 1, 2], ["a", "b", "c"]]'),
            \ [[0, 1, 2], ['a', 'b', 'c']]
            \)
    End

    It decodes dictionaries
      Assert Equals(JSON.decode('{}'), {})
      Assert Equals(
            \ JSON.decode('{"a": 0, "b": 1, "c": 2}'),
            \ {'a': 0, 'b': 1, 'c': 2}
            \)
      Assert Equals(
            \ JSON.decode('{"a": "0", "b": "1", "c": "2"}'),
            \ {'a': '0', 'b': '1', 'c': '2'}
            \)
      " dictionary should be encoded recursively
      Assert Equals(
            \ JSON.decode('{"a": {"b": {"c": [0, 1, 2]}}}'),
            \ {'a': {'b': {'c': [0, 1, 2]}}}
            \)
    End

    It decodes special tokens (true/false/null)
      Assert Same(JSON.decode('true'), v:true)
      Assert Same(JSON.decode('false'), v:false)
      Assert Same(JSON.decode('null'), v:null)
    End

    It decodes special floats (NaN/Infinity/-Infinity)
      Assert Equals(string(JSON.decode('NaN')), 'nan')
      Assert Equals(string(JSON.decode('Infinity')), 'inf')
      Assert Equals(string(JSON.decode('-Infinity')), '-inf')

      let s = { 'allow_nan': 0 }
      Throws /^Vim(\w\+):E121:/ JSON.decode('NaN', s)
      Throws /^Vim(\w\+):E121:/ JSON.decode('Infinity', s)
      Throws /^Vim(\w\+):E121:/ JSON.decode('-Infinity', s)
    End
  End

  Describe .encode()
    It encodes numbers
      Assert Equals(JSON.encode(0), 0)
      Assert Equals(JSON.encode(10), 10)
      Assert Equals(JSON.encode(100), 100)
    End

    It encodes strings
      Assert Equals(JSON.encode(''), '""')
      Assert Equals(JSON.encode('a'), '"a"')
      Assert Equals(JSON.encode("a\rb"), '"a\rb"')
      Assert Equals(JSON.encode("a\nb"), '"a\nb"')
      Assert Equals(JSON.encode("a\tb"), '"a\tb"')
      " double quotation should be escaped
      Assert Equals(
            \ JSON.encode('He said "I''m a vimmer"'),
            \ '"He said \"I''m a vimmer\""'
            \)
      " control chars
      Assert Equals(JSON.encode("\x01\x02\x03\x04\x05\x06\x07"), '"\u0001\u0002\u0003\u0004\u0005\u0006\u0007"')
      Assert Equals(JSON.encode("\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"), '"\b\t\n\u000b\f\r\u000e\u000f"')
      Assert Equals(JSON.encode("\x10\x11\x12\x13\x14\x15\x16\x17"), '"\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017"')
      Assert Equals(JSON.encode("\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"), '"\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f"')
      " multibyte
      Assert Equals(JSON.encode("s¢cĴgё"), '"s¢cĴgё"')
      " UTF-16 surrogate pair
      Assert Equals(JSON.encode("\xf0\x9f\x8d\xa3"), "\"\xf0\x9f\x8d\xa3\"")
    End

    It encodes strings with character encoding
      let str_utf8 = "sあc漢g"
      Assert Equals(JSON.encode(str_utf8), '"sあc漢g"')

      let str_sjis = iconv("sあc漢g", 'utf-8', 'sjis')
      try
        let &encoding = 'sjis'
        let res = JSON.encode(str_sjis)
      finally
        let &encoding = 'utf-8'
      endtry
      Assert Equals(res, '"sあc漢g"')

      let s = { 'from_encoding': 'sjis' }
      Assert Equals(JSON.encode(str_sjis, s), '"sあc漢g"')
    End

    It encodes strings with {settings.ensure_ascii} = true
      let s = { 'ensure_ascii': v:true }
      " multibyte
      Assert Equals(JSON.encode("s¢cĴgё", s), '"s\u00a2c\u0134g\u0451"')
      " UTF-16 surrogate pair
      Assert Equals(JSON.encode("su\xf0\x9f\x8d\xa3shi", s), '"su\ud83c\udf63shi"')
    End

    It encodes lists
      Assert Equals(JSON.encode([]), '[]')
      Assert Equals(JSON.encode([0, 1, 2]), '[0,1,2]')
      Assert Equals(JSON.encode(['a', 'b', 'c']), '["a","b","c"]')
      " list should be encoded recursively
      Assert Equals(
            \ JSON.encode([[0, 1, 2], ['a', 'b', 'c']]),
            \ '[[0,1,2],["a","b","c"]]'
            \)
    End

    It encodes lists with indent when {settings.indent} > 0
      let s = { 'indent': 2 }
      Assert Equals(JSON.encode([], s), '[]')
      Assert Equals(
            \ JSON.encode([0, 1, 2], s),
            \ join([
            \   '[',
            \   '  0,',
            \   '  1,',
            \   '  2',
            \   ']',
            \ ], "\n"),
            \)
      Assert Equals(
            \ JSON.encode(['a', 'b', 'c'], s),
            \ join([
            \   '[',
            \   '  "a",',
            \   '  "b",',
            \   '  "c"',
            \   ']',
            \ ], "\n"),
            \)
      " list should be encoded recursively
      Assert Equals(
            \ JSON.encode([[0, 1, 2, ['a', 'b', 'c']]], s),
            \ join([
            \   '[',
            \   '  [',
            \   '    0,',
            \   '    1,',
            \   '    2,',
            \   '    [',
            \   '      "a",',
            \   '      "b",',
            \   '      "c"',
            \   '    ]',
            \   '  ]',
            \   ']',
            \ ], "\n"),
            \)
    End

    It encodes dictionaries
      Assert Equals(JSON.encode({}), '{}')
      Assert Equals(
            \ JSON.encode({'a': 0, 'b': 1, 'c': 2}),
            \ '{"a":0,"b":1,"c":2}'
            \)
      Assert Equals(
            \ JSON.encode({'a': '0', 'b': '1', 'c': '2'}),
            \ '{"a":"0","b":"1","c":"2"}'
            \)
      " dictionary should be encoded recursively
      Assert Equals(
            \ JSON.encode({'a': {'b': {'c': [0, 1, 2]}}}),
            \ '{"a":{"b":{"c":[0,1,2]}}}',
            \)
    End

    It encodes dictionaries with indent when {settings.indent} > 0
      let s = { 'indent': 2 }
      Assert Equals(JSON.encode({}, s), '{}')
      Assert Equals(
            \ JSON.encode({'a': 0, 'b': 1, 'c': 2}, s),
            \ join([
            \   '{',
            \   '  "a": 0,',
            \   '  "b": 1,',
            \   '  "c": 2',
            \   '}'
            \ ], "\n")
            \)
      Assert Equals(
            \ JSON.encode({'a': '0', 'b': '1', 'c': '2'}, s),
            \ join([
            \   '{',
            \   '  "a": "0",',
            \   '  "b": "1",',
            \   '  "c": "2"',
            \   '}'
            \ ], "\n")
            \)
      " dictionary should be encoded recursively
      Assert Equals(
            \ JSON.encode({'a': {'b': {'c': [0, 1, 2]}}}, s),
            \ join([
            \   '{',
            \   '  "a": {',
            \   '    "b": {',
            \   '      "c": [',
            \   '        0,',
            \   '        1,',
            \   '        2',
            \   '      ]',
            \   '    }',
            \   '  }',
            \   '}',
            \ ], "\n")
            \)
    End

    " JavaScript special tokens
    It encodes special tokens (true/false/null)
      Assert Equals(JSON.encode(JSON.true), 'true')
      Assert Equals(JSON.encode(JSON.false), 'false')
      Assert Equals(JSON.encode(JSON.null), 'null')

      Assert Equals(JSON.encode(v:true), 'true')
      Assert Equals(JSON.encode(v:false), 'false')
      Assert Equals(JSON.encode(v:null), 'null')
      Assert Equals(JSON.encode(v:none), 'null')
    End

    It encodes special floats (NaN/Infinity/-Infinity)
      Assert Equals(JSON.encode(0.0/0), 'NaN')
      Assert Equals(JSON.encode(1.0/0), 'Infinity')
      Assert Equals(JSON.encode(-1.0/0), '-Infinity')

      let s = { 'allow_nan': 0 }
      Throws /^vital: Web.JSON:/ JSON.encode(0.0/0, s)
      Throws /^vital: Web.JSON:/ JSON.encode(1.0/0, s)
      Throws /^vital: Web.JSON:/ JSON.encode(-1.0/0, s)
    End

    It encodes blob
      if !has('patch-8.1.0735')
        Skip no available blob type.
      endif
      Assert Equals(JSON.encode(0z), '[]')
      Assert Equals(JSON.encode(0zFF.00.ED.01.5D.AF), '[255,0,237,1,93,175]')
    End

    It throws exception when encodes funcref
      let Funcref = function('get')
      Throws /^vital: Web\.JSON: Invalid argument: / JSON.encode(Funcref)
    End

    It throws exception when encodes job
      if !exists('*test_null_job')
        Skip no available job type.
      endif
      let job = test_null_job()
      Throws /^vital: Web\.JSON: Invalid argument: / JSON.encode(job)
    End

    It throws exception when encodes channel
      if !exists('*test_null_channel')
        Skip no available channel type.
      endif
      let ch = test_null_channel()
      Throws /^vital: Web\.JSON: Invalid argument: / JSON.encode(ch)
    End
  End
End
